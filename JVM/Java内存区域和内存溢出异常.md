### 运行时数据区域

Java虚拟机在执行Java程序的过程中会把他所管理的内存划分为若干个不同的数据区域，这些区域都有各自不同的用途。  

![image-20210328102423827](C:\Users\dingx\AppData\Roaming\Typora\typora-user-images\image-20210328102423827.png)

- #### 程序计数器

   `当前线程所执行字节码的行号指示器`    字节码解释器的工作就是通过改变这个计数器的值来选去下一条来执行这个字码的指令，他是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

  Java的多线程是通过线程轮流切换完成的。如果一个线程没有执行完就被切换了，等它抢占到CPU资源时，它就需要一个东西来确保它能恢复到正确的执行位置，这个东西就叫做程序计数器。也正是因为这样，所以它是线程私有的。

  如果当前线程正在执行的是一个Java的方法，这个计数器记录的是正在执行虚拟机字节码的指令地址；如果线程执行的是Native方法，这个计数器则为空，所以此区域是唯一一个没有规定任何OutOfMemoryError的区域。

- #### Java虚拟机栈

  与程序计数器是一样，也是线程私有的；它的生命周期和线程相同。每个方法在被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。`每一个方法被调用到执行完毕的过程就相当于在一个栈帧中从入栈到出栈的过程。`

    ![image-20210328112855251](\pic\栈帧.png)




​	通常所说的堆和栈中的栈指的就是虚拟机栈，更多情况下指的是虚拟机栈中的局部变量表的部分。

>  局部变量表  存放了编译期可知的各种Java虚拟机的**基本类型**（boolean、byte、char、short、int、float、long、double）、**对象引用（**reference类型<调用的是堆中的对象 通过 引用指针、句柄、其他与对象相关的位置> 仅含局部变量的，不含有成员变量的）和**returnAddress类型**（指向了一条字节码指令的地址），其中每个局部变量空间有32位，所以long和double会占用两个局部变量空间，其他类型包括对象引用占一个。
>
> 也就是说在进入一个方法的时候，这个方法这栈帧中分配多大的局部变量空间是已经确定的，在运行期间不会改变局部变量表的大小。

> 操作数栈  存储方法内进行了一些运算操作后的结果

> 动态连接  在方法内调用接口 通过字面量连接到具体的实现类，实现Java的动态性。

> 方法出口 也就是返回结果 return 或者发生Exception等

举例：A方法调用了B方法，A方法先入栈创建一个栈帧，B方法在入栈成为栈顶，之后B方法执行完出栈，接着A	方法执行完在出栈

但如果线程请求栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机的容量可以扩展，当栈无法申请到足够的内存时，则会抛出OutOfMemoryError异常。

- #### 本地方法栈

  本地方法栈与虚拟机栈发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法服务（字节码服务），而本地方法栈则是为虚拟机使用到本地的Native方法。

  与虚拟机栈一样本地方法栈也会抛出栈溢出和内存溢出两个异常。

- #### 堆

  是JVM所管理的最大一块区域，被所有线程所共享，在虚拟机启动时创建。此区域的唯一目的是存放对象的实例和数组，几乎所有的对象实例都会在堆上分配内存，也是垃圾回收的主要区域。现在收集器都采用分代收集方法，所以堆内存模型为

  ![堆](\pic\堆.png)

  > ​								**新生代各区比例 eden:s0:s1 = 8:1:1**

  Java的堆可以处于物理不连续的空间中，只要逻辑连续即可。但同样内存不能扩展时抛出OutOfMemoryError异常。

- #### 方法区

  方法区与Java堆一样，是各个线程所共享的区域，它用于存储已被虚拟机所加载的类型信息、常量（final）、静态变量（static）、JIT（即时编译器）编译后的代码缓存等数据。 别名又叫做非堆 ，1.7之前是用永久代来实现的方法区，1.8及之后用的是元空间，所以1.7及之前的版本容易报OOM，也就是当类和静态变量一多就会报错 解决方法就是加大这块内存地址。

- #### **运行是常量池**

  运行时常量池是方法区的一部分。用于存放编译期生成的各种字面量和符号引用。运行时常量池相对于类常量池的优点就是动态性，运行期间可能将新的常量存入池中。这里所说的常量包括：基本类型包装类和String（String.intern（）方法）

- #### 直接内存

  直接内存并不是虚拟机运行时的一部分，也不是Java虚拟机规范中定义的内存区域，但这部分内存被频繁使用也会导致OOM异常的出现。 一般就是根据实际内存设置-Xmx等参数信息，但是会忽略掉实际内存，从而导致异常的出现。